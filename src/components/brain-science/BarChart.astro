---
interface Props {
  id: string;
  labels: string[];
  datasets: Array<{
    label: string;
    data: number[];
    backgroundColor?: string | string[];
    borderColor?: string | string[];
    borderWidth?: number;
  }>;
  title?: string;
  yAxisLabel?: string;
  xAxisLabel?: string;
  stacked?: boolean;
}

const { id, labels, datasets, title, yAxisLabel, xAxisLabel, stacked = false } = Astro.props;

// Serialize data for script
const chartData = {
  labels,
  datasets,
  yAxisLabel: yAxisLabel || '',
  xAxisLabel: xAxisLabel || '',
  stacked,
};
---

<div class="mb-6">
  {
    title && (
      <h3 class="mb-4 text-base font-semibold text-[rgb(var(--color-text))] md:text-lg">{title}</h3>
    )
  }
  <div class="relative h-64 w-full md:h-80" id={`chart-container-${id}`} style="min-height: 256px;">
    <!-- Loading State -->
    <div
      id={`chart-loading-${id}`}
      class="absolute inset-0 flex flex-col items-center justify-center rounded-lg border border-[rgb(var(--color-border))] bg-[rgb(var(--color-bg-alt))]"
    >
      <div class="flex flex-col items-center space-y-3">
        <div class="relative">
          <div
            class="h-8 w-8 animate-spin rounded-full border-4 border-[rgb(var(--color-border))] border-t-[rgb(var(--color-accent))]"
          >
          </div>
        </div>
        <p class="text-sm text-[rgb(var(--color-text-muted))]">Calculating data...</p>
      </div>
    </div>
    <canvas id={id} style="display: block; max-width: 100%; height: 100%;"></canvas>
  </div>
</div>

<script define:vars={{ id, chartData }}>
  (async function initChart() {
    try {
      // Wait for DOM to be ready
      if (document.readyState === 'loading') {
        await new Promise((resolve) => {
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', resolve, { once: true });
          } else {
            resolve(null);
          }
        });
      }

      // Additional small delay to ensure canvas is rendered
      await new Promise((resolve) => setTimeout(resolve, 100));

      // Load Chart.js from CDN
      if (typeof window.Chart === 'undefined') {
        await new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/chart.js@4.5.1/dist/chart.umd.min.js';
          script.onload = resolve;
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }

      const Chart = window.Chart;
      // Register components if registerables exists, otherwise Chart.js from CDN already has everything registered
      if (Chart.registerables && Array.isArray(Chart.registerables)) {
        Chart.register(...Chart.registerables);
      }

      const container = document.getElementById(`chart-container-${id}`);
      const canvas = document.getElementById(id);

      if (!canvas || !container) {
        console.error(`Chart elements not found for id "${id}"`);
        if (container) {
          container.style.display = 'none';
        }
        return;
      }

      if (!chartData || !chartData.labels || !chartData.datasets) {
        console.error('Chart data not found or invalid:', chartData);
        container.style.display = 'none';
        return;
      }

      const { labels, datasets, yAxisLabel, xAxisLabel, stacked } = chartData;

      if (!labels || !Array.isArray(labels) || labels.length === 0) {
        console.warn('Chart labels are empty or invalid');
        container.style.display = 'none';
        return;
      }

      if (!datasets || !Array.isArray(datasets) || datasets.length === 0) {
        console.warn('Chart datasets are empty or invalid');
        container.style.display = 'none';
        return;
      }

      // Check if datasets have valid data
      const hasValidData = datasets.some(
        (ds) => Array.isArray(ds.data) && ds.data.length > 0 && ds.data.some((val) => val != null),
      );

      if (!hasValidData) {
        console.warn('Chart datasets contain no valid data');
        container.style.display = 'none';
        return;
      }

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Could not get 2d context from canvas');
        container.style.display = 'none';
        return;
      }

      // Destroy existing chart if it exists
      if (canvas.chart) {
        canvas.chart.destroy();
      }

      // Chart theme helper functions (inlined for client-side compatibility)
      const getRGB = (varName) => {
        const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        return `rgb(${value})`;
      };
      const getRGBA = (varName, alpha) => {
        const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        return `rgba(${value}, ${alpha})`;
      };
      const theme = {
        text: getRGB('--color-text'),
        textMuted: getRGB('--color-text-muted'),
        border: getRGB('--color-border'),
        bgAlt: getRGB('--color-bg-alt'),
        accent: getRGB('--color-accent'),
      };
      // Helper to resolve CSS variable strings to actual RGB values
      // Always returns a valid color string, never null
      const resolveCSSVariable = (color, fallbackColor) => {
        if (!color || typeof color !== 'string') {
          return fallbackColor || theme.accent;
        }

        // If it contains CSS variable syntax like rgb(var(--color-accent))
        if (color.includes('var(--')) {
          try {
            // Handle rgba(var(--color), alpha) format
            const rgbaMatch = color.match(/rgba\(var\((--[^)]+)\)\s*,\s*([\d.]+)\)/);
            if (rgbaMatch) {
              const varName = rgbaMatch[1];
              const alpha = parseFloat(rgbaMatch[2]);
              const resolved = getRGBA(varName, alpha);
              // Validate the resolved color
              if (resolved && resolved.startsWith('rgba(')) {
                return resolved;
              }
            }

            // Handle rgb(var(--color)) format
            const rgbMatch = color.match(/rgb\(var\((--[^)]+)\)\)/);
            if (rgbMatch) {
              const varName = rgbMatch[1];
              const resolved = getRGB(varName);
              // Validate the resolved color
              if (resolved && resolved.startsWith('rgb(')) {
                return resolved;
              }
            }
          } catch (error) {
            console.warn('Failed to resolve CSS variable:', color, error);
          }

          // If resolution failed, return fallback
          return fallbackColor || theme.accent;
        }

        return color;
      };

      // Helper to ensure colors have transparency (never solid/opaque)
      // Always returns a valid rgba() color string, never null
      const ensureTransparent = (color, defaultAlpha = 0.8, fallbackColor) => {
        // If no color provided, use fallback
        if (!color || typeof color !== 'string') {
          const fallback = fallbackColor || theme.accent;
          // Ensure fallback is also transparent
          if (fallback.startsWith('rgb(')) {
            return fallback.replace('rgb(', 'rgba(').replace(')', `, ${defaultAlpha})`);
          }
          return fallback;
        }

        // First resolve CSS variables if present
        const resolvedColor = resolveCSSVariable(color, fallbackColor);

        // If it's already rgba with alpha, return as is (but validate it's not black)
        if (resolvedColor.includes('rgba')) {
          // Check if it's black and replace with theme color
          if (resolvedColor.includes('rgba(0, 0, 0') || resolvedColor.includes('rgba(0,0,0')) {
            const fallback = fallbackColor || theme.accent;
            return fallback.startsWith('rgba(')
              ? fallback
              : getRGBA('--color-accent', defaultAlpha);
          }
          return resolvedColor;
        }

        // If it's transparent, return as is
        if (resolvedColor === 'transparent') {
          return resolvedColor;
        }

        // If it's rgb, convert to rgba with transparency
        if (resolvedColor.startsWith('rgb(')) {
          // Check if it's black and replace with theme color
          if (resolvedColor.includes('rgb(0, 0, 0') || resolvedColor.includes('rgb(0,0,0')) {
            const fallback = fallbackColor || theme.accent;
            return fallback.startsWith('rgba(')
              ? fallback
              : getRGBA('--color-accent', defaultAlpha);
          }
          return resolvedColor.replace('rgb(', 'rgba(').replace(')', `, ${defaultAlpha})`);
        }

        // Handle named colors and hex
        if (resolvedColor === 'black' || resolvedColor === '#000000' || resolvedColor === '#000') {
          const fallback = fallbackColor || theme.accent;
          return fallback.startsWith('rgba(') ? fallback : getRGBA('--color-accent', defaultAlpha);
        }

        // For any other invalid color, use fallback
        const fallback = fallbackColor || theme.accent;
        return fallback.startsWith('rgba(') ? fallback : getRGBA('--color-accent', defaultAlpha);
      };

      const datasetColors = [
        { border: getRGBA('--color-accent', 0.8), background: getRGBA('--color-accent', 0.5) },
        { border: getRGBA('--color-primary', 0.8), background: getRGBA('--color-primary', 0.5) },
        { border: getRGBA('--color-success', 0.8), background: getRGBA('--color-success', 0.5) },
        { border: getRGBA('--color-warning', 0.8), background: getRGBA('--color-warning', 0.5) },
        {
          border: getRGBA('--color-highlight', 0.8),
          background: getRGBA('--color-highlight', 0.5),
        },
      ];

      const processedDatasets = datasets.map((ds, index) => {
        const colorIndex = index % datasetColors.length;
        const themeColor = datasetColors[colorIndex];

        // Always ensure we have valid colors with transparency
        // Use theme color as fallback if custom color fails
        const borderColor = ds.borderColor
          ? ensureTransparent(ds.borderColor, 0.8, themeColor.border)
          : themeColor.border;
        const backgroundColor = ds.backgroundColor
          ? ensureTransparent(ds.backgroundColor, 0.5, themeColor.background)
          : themeColor.background;

        // Final validation - ensure we never pass null or invalid colors
        const finalBorderColor =
          borderColor && typeof borderColor === 'string' && borderColor.length > 0
            ? borderColor
            : themeColor.border;
        const finalBackgroundColor =
          backgroundColor && typeof backgroundColor === 'string' && backgroundColor.length > 0
            ? backgroundColor
            : themeColor.background;

        return {
          ...ds,
          borderColor: finalBorderColor,
          backgroundColor: finalBackgroundColor,
          borderWidth: ds.borderWidth ?? 2,
        };
      });

      const chart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: processedDatasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: datasets.length > 1,
              position: 'top',
              labels: {
                color: theme.text,
                usePointStyle: true,
                padding: 15,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 12 },
              },
            },
            tooltip: {
              backgroundColor: theme.bgAlt,
              titleColor: theme.text,
              bodyColor: theme.text,
              borderColor: theme.border,
              borderWidth: 1,
              padding: 12,
              titleFont: { family: 'Open Sans, system-ui, sans-serif', size: 13, weight: '600' },
              bodyFont: { family: 'Open Sans, system-ui, sans-serif', size: 12 },
              cornerRadius: 6,
            },
          },
          scales: {
            x: {
              stacked: stacked,
              ticks: {
                color: theme.textMuted,
                maxRotation: 45,
                minRotation: 0,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 11 },
              },
              grid: {
                color: theme.border,
                drawBorder: true,
                borderColor: theme.border,
              },
              title: {
                display: !!xAxisLabel,
                text: xAxisLabel,
                color: theme.textMuted,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 12, weight: '500' },
                padding: { top: 10, bottom: 0 },
              },
            },
            y: {
              beginAtZero: true,
              stacked: stacked,
              ticks: {
                color: theme.textMuted,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 11 },
              },
              grid: {
                color: theme.border,
                drawBorder: true,
                borderColor: theme.border,
              },
              title: {
                display: !!yAxisLabel,
                text: yAxisLabel,
                color: theme.textMuted,
                font: { family: 'Open Sans, system-ui, sans-serif', size: 12, weight: '500' },
                padding: { top: 0, bottom: 10 },
              },
            },
          },
        },
      });

      // Store chart instance on canvas for cleanup
      canvas.chart = chart;

      // Hide loading state
      const loadingEl = document.getElementById(`chart-loading-${id}`);
      if (loadingEl) {
        loadingEl.style.display = 'none';
      }
    } catch (err) {
      console.error('Failed to initialize chart:', err);
      const container = document.getElementById(`chart-container-${id}`);
      const loadingEl = document.getElementById(`chart-loading-${id}`);

      if (loadingEl) {
        loadingEl.innerHTML = `
          <div class="flex flex-col items-center space-y-2 text-center p-4">
            <p class="text-sm font-medium text-red-500">Failed to load chart</p>
            <p class="text-xs text-[rgb(var(--color-text-muted))]">Data may be unavailable</p>
          </div>
        `;
      }

      if (container) {
        container.style.display = 'none';
      }
      // Also hide parent wrapper if it exists
      const wrapper = container?.parentElement;
      if (wrapper && wrapper.classList.contains('mb-6')) {
        wrapper.style.display = 'none';
      }
    }
  })();
</script>
