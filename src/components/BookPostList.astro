---
export interface Props {
	posts: any[];
	chapterTitle: string;
}

const { posts, chapterTitle } = Astro.props;
---

<div class="book-chapter">
	<h2 class="chapter-title">{chapterTitle}</h2>
	{posts.length > 0 ? (
		<ol class="post-list">
			{posts.map((post, index) => (
				<li class="post-item">
					<a href={`/p/${post.slug}`} class="post-link" data-post-slug={post.slug}>
						<span class="post-number">{index + 1}.</span>
						<span class="post-title">{post.data.title}</span>
						<span class="read-indicator" data-post-slug={post.slug}></span>
						{post.data.readingTime && (
							<span class="reading-time">{post.data.readingTime} min</span>
						)}
					</a>
				</li>
			))}
		</ol>
	) : (
		<p class="empty-state">No posts yet in this chapter.</p>
	)}
</div>

<script>
	// Read/unread functionality
	class ReadTracker {
		private storageKey: string;
		private readPosts: string[];

		constructor() {
			this.storageKey = 'curious-chaos-read-posts';
			this.readPosts = this.loadReadPosts();
			this.init();
		}

		private loadReadPosts(): string[] {
			try {
				const stored = localStorage.getItem(this.storageKey);
				return stored ? JSON.parse(stored) : [];
			} catch {
				return [];
			}
		}

		private saveReadPosts(): void {
			try {
				localStorage.setItem(this.storageKey, JSON.stringify(this.readPosts));
			} catch (error) {
				console.warn('Failed to save read posts:', error);
			}
		}

		private markAsRead(postSlug: string): void {
			if (!this.readPosts.includes(postSlug)) {
				this.readPosts.push(postSlug);
				this.saveReadPosts();
				this.updateIndicators();
			}
		}

		private isRead(postSlug: string): boolean {
			return this.readPosts.includes(postSlug);
		}

		private updateIndicators(): void {
			document.querySelectorAll('.read-indicator').forEach(indicator => {
				const postSlug = (indicator as HTMLElement).dataset.postSlug;
				if (postSlug && this.isRead(postSlug)) {
					indicator.classList.add('read');
				} else {
					indicator.classList.remove('read');
				}
			});
		}

		private init(): void {
			// Update indicators on page load
			this.updateIndicators();

			// Listen for scroll events on post pages
			if (window.location.pathname.startsWith('/p/')) {
				this.setupScrollTracking();
			}
		}

		private setupScrollTracking(): void {
			let scrollTimeout: number | undefined;
			
			window.addEventListener('scroll', () => {
				if (scrollTimeout) clearTimeout(scrollTimeout);
				scrollTimeout = window.setTimeout(() => {
					this.checkScrollPosition();
				}, 100);
			});
		}

		private checkScrollPosition(): void {
			const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
			const windowHeight = window.innerHeight;
			const documentHeight = document.documentElement.scrollHeight;
			
			// If user has scrolled to within 100px of the bottom, mark as read
			if (scrollTop + windowHeight >= documentHeight - 100) {
				const postSlug = this.getCurrentPostSlug();
				if (postSlug) {
					this.markAsRead(postSlug);
				}
			}
		}

		private getCurrentPostSlug(): string | null {
			const path = window.location.pathname;
			const match = path.match(/\/p\/(.+)/);
			return match ? match[1] : null;
		}
	}

	// Initialize when DOM is ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
			new ReadTracker();
		});
	} else {
		new ReadTracker();
	}
</script>

<style>
	.book-chapter {
		margin-bottom: 2rem;
	}

	.chapter-title {
		font-size: 1.5rem;
		font-weight: 600;
		margin-bottom: 1rem;
		color: rgb(var(--color-text));
	}

	.post-list {
		list-style: none;
		padding: 0;
		margin: 0;
	}

	.post-item {
		margin-bottom: 0.5rem;
	}

	.post-link {
		display: flex;
		align-items: center;
		gap: 0.75rem;
		padding: 0.5rem 0;
		text-decoration: none;
		color: rgb(var(--color-text));
		border-bottom: 1px solid transparent;
		transition: border-color 0.2s ease;
	}

	.post-link:hover {
		border-bottom-color: rgb(var(--color-primary));
	}

	.post-number {
		font-weight: 500;
		color: rgb(var(--color-text-muted));
		min-width: 2rem;
	}

	.post-title {
		flex: 1;
		font-weight: 400;
	}

	.read-indicator {
		width: 8px;
		height: 8px;
		border-radius: 50%;
		background-color: rgb(var(--color-primary));
		opacity: 0.3;
		transition: opacity 0.2s ease;
	}

	.read-indicator.read {
		opacity: 1;
	}

	.reading-time {
		font-size: 0.875rem;
		color: rgb(var(--color-text-muted));
	}

	.empty-state {
		color: rgb(var(--color-text-muted));
		font-style: italic;
		padding: 1rem 0;
	}
</style> 