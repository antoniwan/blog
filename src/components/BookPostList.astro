---
import { categories } from '../data/categories';

export interface Props {
	posts: any[];
	chapterTitle: string;
}

const { posts, chapterTitle } = Astro.props;

// Helper function to get category name
function getCategoryName(categoryIds: string[] | undefined): string | null {
	if (!categoryIds || categoryIds.length === 0) return null;
	const category = categories.find(cat => cat.id === categoryIds[0]);
	return category ? category.name : categoryIds[0];
}
---

<div class="book-chapter">
	<h2 class="chapter-title">{chapterTitle}</h2>
	{posts.length > 0 ? (
		<ol class="post-list">
			{posts.map((post, index) => {
				const categoryName = getCategoryName(post.data.category);
				return (
					<li class="post-item">
						<a href={`/p/${post.id}`} class="post-link" data-post-slug={post.id}>
							<span class="post-number">{index + 1}.</span>
							<div class="post-content">
								<span class="post-title">{post.data.title}</span>
								{categoryName && (
									<span class="post-category">{categoryName}</span>
								)}
							</div>
							<span class="read-indicator" data-post-slug={post.id}></span>
							{post.data.readingTime && (
								<span class="reading-time">{post.data.readingTime} min</span>
							)}
						</a>
					</li>
				);
			})}
		</ol>
	) : (
		<p class="empty-state">No posts yet in this chapter.</p>
	)}
</div>

<script>
	// Read/unread functionality using shared storage
	class ReadTracker {
		private storageKey = 'curious-chaos-read-posts';

		constructor() {
			this.init();
		}

		private loadReadPosts(): string[] {
			try {
				const stored = localStorage.getItem(this.storageKey);
				return stored ? JSON.parse(stored) : [];
			} catch {
				return [];
			}
		}

		private isRead(postSlug: string): boolean {
			const readData = this.loadReadPosts();
			return readData.some((data: any) => data.postSlug === postSlug);
		}

		private updateIndicators(): void {
			document.querySelectorAll('.read-indicator').forEach(indicator => {
				const postSlug = (indicator as HTMLElement).dataset.postSlug;
				if (postSlug && this.isRead(postSlug)) {
					indicator.classList.add('read');
				} else {
					indicator.classList.remove('read');
				}
			});
		}

		private init(): void {
			// Update indicators on page load
			this.updateIndicators();

			// Listen for post-read events from other components
			window.addEventListener('post-read', (event: any) => {
				this.updateIndicators();
			});

			// Listen for read-posts-cleared events
			window.addEventListener('read-posts-cleared', () => {
				this.updateIndicators();
			});
		}
	}

	// Initialize when DOM is ready
	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', () => {
			new ReadTracker();
		});
	} else {
		new ReadTracker();
	}
</script>

<style>
	.book-chapter {
		margin-bottom: 2rem;
	}

	.chapter-title {
		font-size: 1.5rem;
		font-weight: 600;
		margin-bottom: 1rem;
		color: rgb(var(--color-text));
	}

	.post-list {
		list-style: none;
		padding: 0;
		margin: 0;
	}

	.post-item {
		margin-bottom: 0.5rem;
	}

	.post-link {
		display: flex;
		align-items: center;
		gap: 0.75rem;
		padding: 0.5rem 0;
		text-decoration: none;
		color: rgb(var(--color-text));
		border-bottom: 1px solid transparent;
		transition: border-color 0.2s ease;
	}

	.post-link:hover {
		border-bottom-color: rgb(var(--color-primary));
	}

	.post-number {
		font-weight: 500;
		color: rgb(var(--color-text-muted));
		min-width: 2rem;
	}

	.post-content {
		flex: 1;
		display: flex;
		flex-direction: column;
		gap: 0.25rem;
	}

	.post-title {
		font-weight: 400;
	}

	.post-category {
		font-size: 0.75rem;
		color: rgb(var(--color-primary));
		font-weight: 500;
		text-transform: uppercase;
		letter-spacing: 0.05em;
	}

	.read-indicator {
		width: 8px;
		height: 8px;
		border-radius: 50%;
		background-color: rgb(var(--color-primary));
		opacity: 0.3;
		transition: opacity 0.2s ease;
	}

	.read-indicator.read {
		opacity: 1;
	}

	.reading-time {
		font-size: 0.875rem;
		color: rgb(var(--color-text-muted));
	}

	.empty-state {
		color: rgb(var(--color-text-muted));
		font-style: italic;
		padding: 1rem 0;
	}
</style> 