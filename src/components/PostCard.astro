---
import type { CollectionEntry } from 'astro:content';
import FormattedDate from './FormattedDate.astro';
import TagDisplay from './TagDisplay.astro';
import DefaultImage from './DefaultImage.astro';
import { calculateReadingTimeFromMarkdown } from '../utils/readingTime';

interface Props {
  post: CollectionEntry<'blog'>;
  featured?: boolean;
  compact?: boolean;
}

const { post, featured = false, compact = false } = Astro.props;
const { data } = post;

// Calculate reading time from post content
const readingTime = calculateReadingTimeFromMarkdown(post.body || '');
---

<article
  class="interactive-card group relative overflow-hidden rounded-lg"
  class:list={{
    'featured-card': featured,
    'compact-card': compact,
  }}
  role="article"
  data-post-slug={post.id}
>
  <!-- Read indicator -->
  <div class="read-indicator" data-post-slug={post.id}>
    <span class="read-dot"></span>
  </div>


  <!-- Hero Image Container - Enhanced for consistent sizing and coverage -->
  <div class="image-container relative overflow-hidden rounded-t-lg">
    {
      data.heroImage ? (
        <img
          src={data.heroImage}
          alt={data.title}
          class="h-32 w-full object-cover object-center md:h-40"
          loading="lazy"
        />
      ) : (
        <DefaultImage
          alt={data.title}
          className="w-full h-32 md:h-40 object-cover object-center"
          loading="lazy"
        />
      )
    }
  </div>

  <!-- Card content -->
  <div class="relative p-3 sm:p-4 md:p-5">
    <div class="space-y-2">
      <!-- Header with metadata -->
      <header class="space-y-1.5">
        <div class="text-body-muted flex items-center gap-1.5 text-xs leading-relaxed">
          <FormattedDate date={data.pubDate} />
          <span class="reading-time-display" data-post-slug={post.id}>
            {
              readingTime && (
                <>
                  <span aria-hidden="true">•</span>
                  <span>{readingTime}</span>
                </>
              )
            }
          </span>
          {
            featured && (
              <>
                <span aria-hidden="true">•</span>
                <span
                  class="text-sm font-semibold text-[rgb(var(--color-primary))]"
                  role="img"
                  aria-label="Featured post"
                >
                  ⭐
                </span>
              </>
            )
          }
        </div>

        <h2
          class="text-base font-bold leading-tight text-[rgb(var(--color-text))] sm:text-lg md:text-xl"
        >
          <a href={`/p/${post.id}/`} class="block">
            {data.title}
          </a>
        </h2>
      </header>

      <!-- Description -->
      {
        data.description && (
          <p class="text-body-muted line-clamp-2 text-sm leading-relaxed sm:text-base md:line-clamp-2">
            {data.description}
          </p>
        )
      }

      <!-- Tags -->
      {
        data.tags && data.tags.length > 0 && (
          <footer class="pt-1">
            <TagDisplay tags={data.tags} maxVisible={3} showMoreIndicator={true} compact={true} />
          </footer>
        )
      }
    </div>
  </div>

</article>

<script>
  // Read status indicator for PostCard
  // Storage constants - using direct values since import doesn't work in Astro client scripts
  const STORAGE_KEY = 'blog-read-posts-v1.0';
  const FALLBACK_KEY = 'blog-read-posts';

  class PostCardReadIndicator {
    private storageKey: string;
    private fallbackKey: string;
    private boundPostReadHandler: () => void;
    private boundClearedHandler: () => void;
    private boundStorageHandler: (event: any) => void;
    private boundDataUpdatedHandler: (event: any) => void;

    constructor() {
      this.storageKey = STORAGE_KEY;
      this.fallbackKey = FALLBACK_KEY;
      this.boundPostReadHandler = this.handlePostRead.bind(this);
      this.boundClearedHandler = this.handleClearedPosts.bind(this);
      this.boundStorageHandler = this.handleStorageChange.bind(this);
      this.boundDataUpdatedHandler = this.handleDataUpdated.bind(this);
      this.init();
    }

    loadReadPosts() {
      try {
        const stored =
          localStorage.getItem(this.storageKey) || localStorage.getItem(this.fallbackKey);
        if (!stored) return [];

        const parsed = JSON.parse(stored);

        // Validate data structure
        if (!Array.isArray(parsed)) {
          return [];
        }

        // Filter and validate individual items
        return parsed.filter((item) => {
          if (!item || typeof item !== 'object') return false;

          const hasValidSlug = typeof item.postSlug === 'string' && item.postSlug.trim().length > 0;
          const hasValidDate = typeof item.readAt === 'string' && !isNaN(Date.parse(item.readAt));

          if (!hasValidSlug || !hasValidDate) {
            return false;
          }

          return true;
        });
      } catch (error) {
        return [];
      }
    }

    getReadData(postSlug: string) {
      const readData = this.loadReadPosts();
      return readData.find((data) => data.postSlug === postSlug) || null;
    }

    updateIndicators() {
      document.querySelectorAll('.read-indicator').forEach((indicator) => {
        const postSlug = (indicator as HTMLElement).dataset.postSlug;
        const dot = indicator.querySelector('.read-dot');

        if (postSlug && dot) {
          const readData = this.getReadData(postSlug);
          const readingTimeElement = document.querySelector(
            `.reading-time-display[data-post-slug="${postSlug}"]`,
          ) as HTMLElement;

          if (readData) {
            dot.classList.add('read');
            indicator.setAttribute('title', 'Read');
            // Hide reading time for read posts
            if (readingTimeElement) {
              readingTimeElement.style.display = 'none';
            }
          } else {
            dot.classList.remove('read');
            indicator.setAttribute('title', 'Unread');
            // Show reading time for unread posts
            if (readingTimeElement) {
              readingTimeElement.style.display = 'inline';
            }
          }
        }
      });
    }

    handlePostRead() {
      this.updateIndicators();
    }

    handleClearedPosts() {
      this.updateIndicators();
    }

    handleStorageChange(event: any) {
      // React to localStorage changes from other tabs/windows
      if (event.key === this.storageKey || event.key === this.fallbackKey) {
        this.updateIndicators();
      }
    }

    handleDataUpdated(event: any) {
      // React to immediate data updates from same tab
      if (event.detail?.type === 'post-read') {
        this.updateIndicators();
      }
    }

    init() {
      // Update indicators on page load
      this.updateIndicators();

      // Listen for post-read events from other components
      window.addEventListener('post-read', this.boundPostReadHandler);

      // Listen for read-posts-cleared events
      window.addEventListener('read-posts-cleared', this.boundClearedHandler);

      // Listen for storage events (cross-tab synchronization)
      window.addEventListener('storage', this.boundStorageHandler);

      // Listen for immediate data updates (same-tab reactivity)
      window.addEventListener('reading-data-updated', this.boundDataUpdatedHandler);
    }

    cleanup() {
      window.removeEventListener('post-read', this.boundPostReadHandler);
      window.removeEventListener('read-posts-cleared', this.boundClearedHandler);
      window.removeEventListener('storage', this.boundStorageHandler);
      window.removeEventListener('reading-data-updated', this.boundDataUpdatedHandler);
    }
  }

  // Initialize when DOM is ready
  let postCardIndicator: PostCardReadIndicator;

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      postCardIndicator = new PostCardReadIndicator();
    });
  } else {
    postCardIndicator = new PostCardReadIndicator();
  }

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    if (postCardIndicator) {
      postCardIndicator.cleanup();
    }
  });
</script>

<style>
  /* Read indicator styling */
  .read-indicator {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    z-index: 10;
    pointer-events: none;
  }

  .read-dot {
    display: block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: rgb(var(--color-border));
    border: 2px solid rgb(var(--color-bg));
    transition: all 0.2s ease;
  }

  .read-dot.read {
    background: rgb(34, 197, 94);
    border-color: rgb(var(--color-bg));
    box-shadow: 0 0 0 2px rgb(34, 197, 94, 0.2);
  }

  /* Simplified card styling */
  article {
    transition: box-shadow 0.2s ease, border-color 0.2s ease;
    border: 1px solid rgb(var(--color-border) / 0.2);
    box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
  }

  /* Enhanced image container styling for consistent sizing and coverage */
  .image-container {
    position: relative;
    width: 100%;
    height: 8rem; /* 128px - compact height for mobile */
    background: rgb(var(--color-bg-alt));
    overflow: hidden;
  }

  /* Ensure images cover the entire container */
  .image-container img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    display: block;
    border: none;
    outline: none;
    margin: 0;
  }

  /* Responsive image heights */
  @media (min-width: 768px) {
    .image-container {
      height: 10rem; /* 160px - compact height for desktop */
    }
  }

  /* Simplified featured card styling */
  .featured-card {
    border: 2px solid rgb(var(--color-primary) / 0.3);
    box-shadow: 0 4px 12px -2px rgb(var(--color-primary) / 0.15);
  }

  /* Compact card styling */
  .compact-card {
    @apply p-3 sm:p-4 md:p-6;
  }

  .compact-card .space-y-3 > * + * {
    margin-top: 0.75rem;
  }

  .compact-card .space-y-4 > * + * {
    margin-top: 1rem;
  }

  .compact-card .space-y-5 > * + * {
    margin-top: 1.25rem;
  }

  /* Simplified hover effects */
  .group:hover {
    box-shadow: 0 4px 12px -2px rgb(0 0 0 / 0.15);
    border-color: rgb(var(--color-primary) / 0.3);
  }

  /* Enhanced focus states */
  .group:focus-within {
    outline: 2px solid rgb(var(--color-primary));
    outline-offset: 2px;
    border-radius: 0.75rem;
  }

  /* Improved line heights for better readability */
  .text-lg {
    line-height: 1.4;
  }

  .text-xl {
    line-height: 1.4;
  }

  .text-2xl {
    line-height: 1.3;
  }

  .text-3xl {
    line-height: 1.2;
  }

  /* Enhanced spacing between elements */
  .space-y-3 > * + * {
    margin-top: 0.75rem;
  }

  .space-y-4 > * + * {
    margin-top: 1rem;
  }

  .space-y-5 > * + * {
    margin-top: 1.25rem;
  }

  /* Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    article {
      transition: none !important;
    }

    .group:hover {
      transform: none;
    }

    .read-dot {
      transition: none !important;
    }

  }
</style>
